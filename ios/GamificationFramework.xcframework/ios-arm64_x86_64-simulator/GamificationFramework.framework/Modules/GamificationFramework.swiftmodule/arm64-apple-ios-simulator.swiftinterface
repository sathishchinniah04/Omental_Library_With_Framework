// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-ios15.2-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name GamificationFramework
// swift-module-flags-ignorable: -enable-bare-slash-regex
import CoreGraphics
import CoreText
import Foundation
@_exported import GamificationFramework
import ImageIO
import QuartzCore
import Swift
import UIKit
import UIKit/*.UIKit*/
import UIKit
import _Concurrency
import _StringProcessing
@objc public class IQInvocation : ObjectiveC.NSObject {
  @objc weak public var target: Swift.AnyObject?
  @objc public var action: ObjectiveC.Selector
  @objc public init(_ target: Swift.AnyObject, _ action: ObjectiveC.Selector)
  @objc public func invoke(from: Any)
  @objc deinit
}
extension GamificationFramework.IQKeyboardManager {
  @objc dynamic public var movedDistance: CoreFoundation.CGFloat {
    @objc get
  }
  @objc dynamic public var movedDistanceChanged: ((CoreFoundation.CGFloat) -> Swift.Void)? {
    @objc get
    @objc set(newValue)
  }
}
@_inheritsConvenienceInitializers @objc @_Concurrency.MainActor(unsafe) public class IQPreviousNextView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
final public class GradientValueProvider : GamificationFramework.AnyValueProvider {
  public typealias ColorsValueBlock = (CoreFoundation.CGFloat) -> [GamificationFramework.Color]
  public typealias ColorLocationsBlock = (CoreFoundation.CGFloat) -> [Swift.Double]
  final public var colors: [GamificationFramework.Color] {
    get
    set
  }
  final public var locations: [Swift.Double] {
    get
    set
  }
  public init(block: @escaping GamificationFramework.GradientValueProvider.ColorsValueBlock, locations: GamificationFramework.GradientValueProvider.ColorLocationsBlock? = nil)
  public init(_ colors: [GamificationFramework.Color], locations: [Swift.Double] = [])
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
public protocol AnimationCacheProvider {
  func animation(forKey: Swift.String) -> GamificationFramework.Animation?
  func setAnimation(_ animation: GamificationFramework.Animation, forKey: Swift.String)
  func clearCache()
}
extension UIKit.UIFont {
  public static let loadMyFonts: ()
}
extension UIKit.UIApplication {
  @_Concurrency.MainActor(unsafe) public static let configureFacebookId: ()
}
public enum LayerType : Swift.Int, Swift.Codable {
  case precomp
  case solid
  case image
  case null
  case shape
  case text
  public init(from decoder: any Swift.Decoder) throws
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum MatteType : Swift.Int, Swift.Codable {
  case none
  case add
  case invert
  case unknown
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum BlendMode : Swift.Int, Swift.Codable {
  case normal
  case multiply
  case screen
  case overlay
  case darken
  case lighten
  case colorDodge
  case colorBurn
  case hardLight
  case softLight
  case difference
  case exclusion
  case hue
  case saturation
  case color
  case luminosity
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public typealias LottieCompletionBlock = (Swift.Bool) -> Swift.Void
public enum CoordinateSpace : Swift.Int, Swift.Codable {
  case type2d
  case type3d
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
final public class Animation : Swift.Codable {
  final public let startFrame: GamificationFramework.AnimationFrameTime
  final public let endFrame: GamificationFramework.AnimationFrameTime
  final public let framerate: Swift.Double
  final public var markerNames: [Swift.String] {
    get
  }
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  final public func encode(to encoder: any Swift.Encoder) throws
}
public class Asset : Swift.Codable {
  final public let id: Swift.String
  required public init(from decoder: any Swift.Decoder) throws
  @objc deinit
  public func encode(to encoder: any Swift.Encoder) throws
}
public typealias AnimationFrameTime = CoreFoundation.CGFloat
public typealias AnimationProgressTime = CoreFoundation.CGFloat
@objc @_Concurrency.MainActor(unsafe) open class AnimatedControl : UIKit.UIControl {
  @_Concurrency.MainActor(unsafe) final public let animationView: GamificationFramework.AnimationView
  @_Concurrency.MainActor(unsafe) public var animation: GamificationFramework.Animation? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) public func setLayer(named: Swift.String, forState: UIKit.UIControl.State)
  @_Concurrency.MainActor(unsafe) public func setValueProvider(_ valueProvider: any GamificationFramework.AnyValueProvider, keypath: GamificationFramework.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) public init(animation: GamificationFramework.Animation)
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isEnabled: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isSelected: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var isHighlighted: Swift.Bool {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func continueTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func cancelTracking(with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @_Concurrency.MainActor(unsafe) open func animationDidSet()
  @objc deinit
}
final public class PointValueProvider : GamificationFramework.AnyValueProvider {
  public typealias PointValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGPoint
  final public var point: CoreFoundation.CGPoint {
    get
    set
  }
  public init(block: @escaping GamificationFramework.PointValueProvider.PointValueBlock)
  public init(_ point: CoreFoundation.CGPoint)
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
@objc open class FortuneWheelLayer : QuartzCore.CALayer {
  open var layerInsets: UIKit.UIEdgeInsets
  public init(frame: CoreFoundation.CGRect, parent: GamificationFramework.TTFortuneWheel, initialOffset: CoreFoundation.CGFloat = 0.0)
  @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic open func draw(in ctx: CoreGraphics.CGContext)
  open func drawCanvas(mainFrame: CoreFoundation.CGRect)
  open func drawSlice(withIndex index: Swift.Int, in context: CoreGraphics.CGContext, forSlice slice: any GamificationFramework.FortuneWheelSliceProtocol, rotation: CoreFoundation.CGFloat)
  @objc deinit
}
final public class FloatValueProvider : GamificationFramework.AnyValueProvider {
  public typealias CGFloatValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGFloat
  final public var float: CoreFoundation.CGFloat {
    get
    set
  }
  public init(block: @escaping GamificationFramework.FloatValueProvider.CGFloatValueBlock)
  public init(_ float: CoreFoundation.CGFloat)
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class IQTitleBarButtonItem : GamificationFramework.IQBarButtonItem {
  @objc @_Concurrency.MainActor(unsafe) open var titleFont: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var title: Swift.String? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var titleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open var selectableTitleColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override open var invocation: GamificationFramework.IQInvocation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) convenience public init(title: Swift.String?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class AnimationSubview : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
@objc public enum IQAutoToolbarManageBehaviour : Swift.Int {
  case bySubviews
  case byTag
  case byPosition
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum IQPreviousNextDisplayMode : Swift.Int {
  case `default`
  case alwaysHide
  case alwaysShow
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum IQEnableMode : Swift.Int {
  case `default`
  case enabled
  case disabled
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public protocol AnyValueProvider {
  var valueType: any Any.Type { get }
  func hasUpdate(frame: GamificationFramework.AnimationFrameTime) -> Swift.Bool
  func value(frame: GamificationFramework.AnimationFrameTime) -> Any
}
extension GamificationFramework.IQKeyboardManager {
  @objc dynamic public func reloadInputViews()
}
extension GamificationFramework.IQKeyboardManager {
  @objc dynamic public var canGoPrevious: Swift.Bool {
    @objc get
  }
  @objc dynamic public var canGoNext: Swift.Bool {
    @objc get
  }
  @discardableResult
  @objc dynamic public func goPrevious() -> Swift.Bool
  @discardableResult
  @objc dynamic public func goNext() -> Swift.Bool
}
extension UIKit.UIView {
  @_Concurrency.MainActor(unsafe) public func addBlur(style: UIKit.UIBlurEffect.Style = .extraLight) -> UIKit.UIVisualEffectView
}
@objc extension UIKit.UIScrollView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldIgnoreScrollingAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldIgnoreContentInsetAdjustment: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldRestoreScrollViewContentOffset: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class IQKeyboardManager : ObjectiveC.NSObject {
  @objc public static let shared: GamificationFramework.IQKeyboardManager
  @objc public var enable: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var keyboardDistanceFromTextField: CoreFoundation.CGFloat
  @objc public var enableAutoToolbar: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var toolbarManageBehaviour: GamificationFramework.IQAutoToolbarManageBehaviour
  @objc public var shouldToolbarUsesTextFieldTintColor: Swift.Bool
  @objc public var toolbarTintColor: UIKit.UIColor?
  @objc public var toolbarBarTintColor: UIKit.UIColor?
  @objc public var previousNextDisplayMode: GamificationFramework.IQPreviousNextDisplayMode
  @objc public var toolbarPreviousBarButtonItemImage: UIKit.UIImage?
  @objc public var toolbarNextBarButtonItemImage: UIKit.UIImage?
  @objc public var toolbarDoneBarButtonItemImage: UIKit.UIImage?
  @objc public var toolbarPreviousBarButtonItemText: Swift.String?
  @objc public var toolbarPreviousBarButtonItemAccessibilityLabel: Swift.String?
  @objc public var toolbarNextBarButtonItemText: Swift.String?
  @objc public var toolbarNextBarButtonItemAccessibilityLabel: Swift.String?
  @objc public var toolbarDoneBarButtonItemText: Swift.String?
  @objc public var toolbarDoneBarButtonItemAccessibilityLabel: Swift.String?
  @objc public var shouldShowToolbarPlaceholder: Swift.Bool
  @objc public var placeholderFont: UIKit.UIFont?
  @objc public var placeholderColor: UIKit.UIColor?
  @objc public var placeholderButtonColor: UIKit.UIColor?
  @objc public var overrideKeyboardAppearance: Swift.Bool
  @objc public var keyboardAppearance: UIKit.UIKeyboardAppearance
  @objc public var shouldResignOnTouchOutside: Swift.Bool {
    @objc get
    @objc set
  }
  @objc public var resignFirstResponderGesture: UIKit.UITapGestureRecognizer {
    @objc get
    @objc set
  }
  @discardableResult
  @objc public func resignFirstResponder() -> Swift.Bool
  @objc public var shouldPlayInputClicks: Swift.Bool
  @objc public var layoutIfNeededOnUpdate: Swift.Bool
  @objc public var disabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc public var enabledDistanceHandlingClasses: [UIKit.UIViewController.Type]
  @objc public var disabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc public var enabledToolbarClasses: [UIKit.UIViewController.Type]
  @objc public var toolbarPreviousNextAllowedClasses: [UIKit.UIView.Type]
  @objc public var disabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc public var enabledTouchResignedClasses: [UIKit.UIViewController.Type]
  @objc public var touchResignedGestureIgnoreClasses: [UIKit.UIView.Type]
  @objc public func registerTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc public func unregisterTextFieldViewClass(_ aClass: UIKit.UIView.Type, didBeginEditingNotificationName: Swift.String, didEndEditingNotificationName: Swift.String)
  @objc deinit
  @objc public func reloadLayoutIfNeeded()
}
extension GamificationFramework.IQKeyboardManager : UIKit.UIGestureRecognizerDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: UIKit.UIGestureRecognizer) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func gestureRecognizer(_ gestureRecognizer: UIKit.UIGestureRecognizer, shouldReceive touch: UIKit.UITouch) -> Swift.Bool
}
public struct StrokeInfo {
  public var color: UIKit.UIColor
  public var width: CoreFoundation.CGFloat
  public init(color: UIKit.UIColor, width: CoreFoundation.CGFloat)
}
public protocol FortuneWheelSliceProtocol {
  var title: Swift.String { get }
  var backgroundColor: UIKit.UIColor? { get }
  var degree: CoreFoundation.CGFloat { get }
  var stroke: GamificationFramework.StrokeInfo? { get }
  var offsetFromExterior: CoreFoundation.CGFloat { get }
  var textAttributes: [Foundation.NSAttributedString.Key : Any] { get }
  var fontSize: CoreFoundation.CGFloat { get }
  var fontColor: UIKit.UIColor { get }
  var font: UIKit.UIFont { get }
  func drawAdditionalGraphics(in context: CoreGraphics.CGContext, circularSegmentHeight: CoreFoundation.CGFloat, radius: CoreFoundation.CGFloat, sliceDegree: CoreFoundation.CGFloat)
}
extension GamificationFramework.FortuneWheelSliceProtocol {
  public func drawAdditionalGraphics(in context: CoreGraphics.CGContext, circularSegmentHeight: CoreFoundation.CGFloat, radius: CoreFoundation.CGFloat, sliceDegree: CoreFoundation.CGFloat)
  public var fontSize: CoreFoundation.CGFloat {
    get
  }
  public var fontColor: UIKit.UIColor {
    get
  }
  public var font: UIKit.UIFont {
    get
  }
  public var textAttributes: [Foundation.NSAttributedString.Key : Any] {
    get
  }
  public var offsetFromExterior: CoreFoundation.CGFloat {
    get
  }
  public var stroke: GamificationFramework.StrokeInfo? {
    get
  }
  public var backgroundColor: UIKit.UIColor? {
    get
  }
}
public enum GamesList {
  case SpinAndWin
  case ReferAndWin
  case GuessTheBrand
  case SurveyDelight
  case StayActiveAndWin
  case ShakePhoneAndWin
  case ShakeBoxAndWin
  case PredictTheWinner
  case DownloadAndWinVoucher
  case Jackpot
  case Greeting
  case FantasticWeek
  case Lottery
  case SurpriseLottery
  case MegaLottery
  case ActivityAssigmentFamily
  case MemoryGame
  case RollAndWin
  case Quiz
  case Sudoko
  case Football
  case FootballRandomRewardSelection
  case FindThePlayer
  case RandomBallSelection
  case GuessTheScore
  case FootballQuestionnaire
  case FootballShakePhoneAndWin
  case GuessTheJersey
  case EmblemPrediction
  case BuyTicketAndWinGifts
  public static func == (a: GamificationFramework.GamesList, b: GamificationFramework.GamesList) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class AnimatedSwitch : GamificationFramework.AnimatedControl {
  public enum CancelBehavior {
    case reverse
    case none
    public static func == (a: GamificationFramework.AnimatedSwitch.CancelBehavior, b: GamificationFramework.AnimatedSwitch.CancelBehavior) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  @_Concurrency.MainActor(unsafe) final public var isOn: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var cancelBehavior: GamificationFramework.AnimatedSwitch.CancelBehavior
  @_Concurrency.MainActor(unsafe) final public func setIsOn(_ isOn: Swift.Bool, animated: Swift.Bool, shouldFireHaptics: Swift.Bool = true)
  @_Concurrency.MainActor(unsafe) final public func setProgressForState(fromProgress: GamificationFramework.AnimationProgressTime, toProgress: GamificationFramework.AnimationProgressTime, forOnState: Swift.Bool)
  @_Concurrency.MainActor(unsafe) override public init(animation: GamificationFramework.Animation)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override final public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @_Concurrency.MainActor(unsafe) override final public func animationDidSet()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class IQTextView : UIKit.UITextView {
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect, textContainer: UIKit.NSTextContainer?)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func awakeFromNib()
  @objc deinit
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholderTextColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @IBInspectable @_Concurrency.MainActor(unsafe) open var placeholder: Swift.String? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) open var attributedPlaceholder: Foundation.NSAttributedString? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var text: Swift.String! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var attributedText: Foundation.NSAttributedString! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var font: UIKit.UIFont? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var textAlignment: UIKit.NSTextAlignment {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override weak dynamic open var delegate: (any UIKit.UITextViewDelegate)? {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class ImageAsset : GamificationFramework.Asset {
  final public let name: Swift.String
  final public let directory: Swift.String
  final public let width: Swift.Double
  final public let height: Swift.Double
  override final public func encode(to encoder: any Swift.Encoder) throws
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class LottieView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func didMoveToWindow()
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
extension GamificationFramework.Vector1D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension GamificationFramework.Vector3D : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
extension GamificationFramework.Vector3D {
  public var pointValue: CoreFoundation.CGPoint {
    get
  }
  public var sizeValue: CoreFoundation.CGSize {
    get
  }
}
public struct Vector1D {
  public init(_ value: Swift.Double)
  public let value: Swift.Double
}
public struct Vector3D {
  public let x: Swift.Double
  public let y: Swift.Double
  public let z: Swift.Double
  public init(x: Swift.Double, y: Swift.Double, z: Swift.Double)
}
extension QuartzCore.CALayer {
  public func logLayerTree(withIndent: Swift.Int = 0)
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) open class IQBarButtonItem : UIKit.UIBarButtonItem {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) open func setTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector?)
  @objc @_Concurrency.MainActor(unsafe) open var invocation: GamificationFramework.IQInvocation?
  @objc deinit
}
public enum LottieBackgroundBehavior {
  case stop
  case pause
  case pauseAndRestore
  case forceFinish
  public static func == (a: GamificationFramework.LottieBackgroundBehavior, b: GamificationFramework.LottieBackgroundBehavior) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LottieLoopMode {
  case playOnce
  case loop
  case autoReverse
  case `repeat`(Swift.Float)
  case repeatBackwards(Swift.Float)
}
extension GamificationFramework.LottieLoopMode : Swift.Equatable {
  public static func == (lhs: GamificationFramework.LottieLoopMode, rhs: GamificationFramework.LottieLoopMode) -> Swift.Bool
}
@objc @_inheritsConvenienceInitializers @IBDesignable @_Concurrency.MainActor(unsafe) final public class AnimationView : GamificationFramework.LottieView {
  @_Concurrency.MainActor(unsafe) final public var animation: GamificationFramework.Animation? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var backgroundBehavior: GamificationFramework.LottieBackgroundBehavior
  @_Concurrency.MainActor(unsafe) final public var imageProvider: any GamificationFramework.AnimationImageProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var textProvider: any GamificationFramework.AnimationTextProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var fontProvider: any GamificationFramework.AnimationFontProvider {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimationPlaying: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var isAnimationQueued: Swift.Bool {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var loopMode: GamificationFramework.LottieLoopMode {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var shouldRasterizeWhenIdle: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentProgress: GamificationFramework.AnimationProgressTime {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentTime: Foundation.TimeInterval {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var currentFrame: GamificationFramework.AnimationFrameTime {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var realtimeAnimationFrame: GamificationFramework.AnimationFrameTime {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var realtimeAnimationProgress: GamificationFramework.AnimationProgressTime {
    get
  }
  @_Concurrency.MainActor(unsafe) final public var animationSpeed: CoreFoundation.CGFloat {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var respectAnimationFrameRate: Swift.Bool {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public var viewportFrame: CoreFoundation.CGRect? {
    get
    set
  }
  @_Concurrency.MainActor(unsafe) final public func play(completion: GamificationFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromProgress: GamificationFramework.AnimationProgressTime? = nil, toProgress: GamificationFramework.AnimationProgressTime, loopMode: GamificationFramework.LottieLoopMode? = nil, completion: GamificationFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromFrame: GamificationFramework.AnimationFrameTime? = nil, toFrame: GamificationFramework.AnimationFrameTime, loopMode: GamificationFramework.LottieLoopMode? = nil, completion: GamificationFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func play(fromMarker: Swift.String? = nil, toMarker: Swift.String, loopMode: GamificationFramework.LottieLoopMode? = nil, completion: GamificationFramework.LottieCompletionBlock? = nil)
  @_Concurrency.MainActor(unsafe) final public func stop()
  @_Concurrency.MainActor(unsafe) final public func pause()
  @_Concurrency.MainActor(unsafe) final public func reloadImages()
  @_Concurrency.MainActor(unsafe) final public func forceDisplayUpdate()
  @_Concurrency.MainActor(unsafe) final public func setValueProvider(_ valueProvider: any GamificationFramework.AnyValueProvider, keypath: GamificationFramework.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func getValue(for keypath: GamificationFramework.AnimationKeypath, atFrame: GamificationFramework.AnimationFrameTime?) -> Any?
  @_Concurrency.MainActor(unsafe) final public func logHierarchyKeypaths()
  @_Concurrency.MainActor(unsafe) final public func addSubview(_ subview: GamificationFramework.AnimationSubview, forLayerAt keypath: GamificationFramework.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func convert(_ rect: CoreFoundation.CGRect, toLayerAt keypath: GamificationFramework.AnimationKeypath?) -> CoreFoundation.CGRect?
  @_Concurrency.MainActor(unsafe) final public func convert(_ point: CoreFoundation.CGPoint, toLayerAt keypath: GamificationFramework.AnimationKeypath?) -> CoreFoundation.CGPoint?
  @_Concurrency.MainActor(unsafe) final public func setNodeIsEnabled(isEnabled: Swift.Bool, keypath: GamificationFramework.AnimationKeypath)
  @_Concurrency.MainActor(unsafe) final public func progressTime(forMarker named: Swift.String) -> GamificationFramework.AnimationProgressTime?
  @_Concurrency.MainActor(unsafe) final public func frameTime(forMarker named: Swift.String) -> GamificationFramework.AnimationFrameTime?
  @_Concurrency.MainActor(unsafe) public init(animation: GamificationFramework.Animation?, imageProvider: (any GamificationFramework.AnimationImageProvider)? = nil, textProvider: any GamificationFramework.AnimationTextProvider = DefaultTextProvider(), fontProvider: any GamificationFramework.AnimationFontProvider = DefaultFontProvider())
  @_Concurrency.MainActor(unsafe) @objc dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override final public var intrinsicContentSize: CoreFoundation.CGSize {
    @objc get
  }
  @objc deinit
}
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func viewContainingController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func topMostController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func parentContainerViewController() -> UIKit.UIViewController?
  @objc @_Concurrency.MainActor(unsafe) dynamic public func superviewOfClassType(_ classType: UIKit.UIView.Type, belowView: UIKit.UIView? = nil) -> UIKit.UIView?
}
extension GamificationFramework.IQKeyboardManager {
  @objc dynamic public var keyboardShowing: Swift.Bool {
    @objc get
  }
  public typealias UIViewAnimationOptions = UIKit.UIView.AnimationOptions
}
@objc final public class CompatibleAnimationKeypath : ObjectiveC.NSObject {
  @objc public init(keypath: Swift.String)
  @objc public init(keys: [Swift.String])
  final public let animationKeypath: GamificationFramework.AnimationKeypath
  @objc deinit
}
public protocol AnimationImageProvider {
  func imageForAsset(asset: GamificationFramework.ImageAsset) -> CoreGraphics.CGImage?
}
public class CarnivalWheelSlice : GamificationFramework.FortuneWheelSliceProtocol {
  public enum Style {
    case brickRed
    case sandYellow
    case babyBlue
    case deepBlue
    public static func == (a: GamificationFramework.CarnivalWheelSlice.Style, b: GamificationFramework.CarnivalWheelSlice.Style) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var title: Swift.String
  public var degree: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor? {
    get
  }
  public var fontColor: UIKit.UIColor {
    get
  }
  public var offsetFromExterior: CoreFoundation.CGFloat {
    get
  }
  public var font: UIKit.UIFont {
    get
  }
  public var stroke: GamificationFramework.StrokeInfo? {
    get
  }
  public var style: GamificationFramework.CarnivalWheelSlice.Style
  public init(title: Swift.String)
  convenience public init(title: Swift.String, degree: CoreFoundation.CGFloat)
  @objc deinit
}
infix operator +| : DefaultPrecedence
infix operator +- : DefaultPrecedence
public class LRUAnimationCache : GamificationFramework.AnimationCacheProvider {
  public init()
  public func clearCache()
  public static let sharedCache: GamificationFramework.LRUAnimationCache
  public var cacheSize: Swift.Int
  public func animation(forKey: Swift.String) -> GamificationFramework.Animation?
  public func setAnimation(_ animation: GamificationFramework.Animation, forKey: Swift.String)
  @objc deinit
}
extension UIKit.UIColor {
  public class func uiColor(from rgbValue: Swift.UInt, alpha: CoreFoundation.CGFloat = 1.0) -> UIKit.UIColor
}
public enum ColorFormatDenominator {
  case One
  case OneHundred
  case TwoFiftyFive
  public static func == (a: GamificationFramework.ColorFormatDenominator, b: GamificationFramework.ColorFormatDenominator) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Color {
  public var r: Swift.Double
  public var g: Swift.Double
  public var b: Swift.Double
  public var a: Swift.Double
  public init(r: Swift.Double, g: Swift.Double, b: Swift.Double, a: Swift.Double, denominator: GamificationFramework.ColorFormatDenominator = .One)
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) open class IQToolbar : UIKit.UIToolbar, UIKit.UIInputViewAudioFeedback {
  @objc @_Concurrency.MainActor(unsafe) open var previousBarButton: GamificationFramework.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var nextBarButton: GamificationFramework.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var titleBarButton: GamificationFramework.IQTitleBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var doneBarButton: GamificationFramework.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) open var fixedSpaceBarButton: GamificationFramework.IQBarButtonItem {
    @objc get
    @objc set(newValue)
  }
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func sizeThatFits(_ size: CoreFoundation.CGSize) -> CoreFoundation.CGSize
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var tintColor: UIKit.UIColor! {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic open func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc open var enableInputClicksWhenVisible: Swift.Bool {
    @objc get
  }
  @objc deinit
}
@objc @_Concurrency.MainActor(unsafe) public class TTFortuneWheel : UIKit.UIControl, QuartzCore.CAAnimationDelegate {
  @_Concurrency.MainActor(unsafe) open var equalSlices: Swift.Bool
  @_Concurrency.MainActor(unsafe) open var slices: [any GamificationFramework.FortuneWheelSliceProtocol]!
  @_Concurrency.MainActor(unsafe) open var frameStroke: GamificationFramework.StrokeInfo
  @_Concurrency.MainActor(unsafe) open var shadow: UIKit.NSShadow?
  @_Concurrency.MainActor(unsafe) open var initialDrawingOffset: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) open var titleRotation: CoreFoundation.CGFloat
  @_Concurrency.MainActor(unsafe) public init(frame: CoreFoundation.CGRect, slices: [any GamificationFramework.FortuneWheelSliceProtocol])
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func layoutSubviews()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func draw(_ rect: CoreFoundation.CGRect)
  @_Concurrency.MainActor(unsafe) open func startAnimating(rotationCompletionOffset: CoreFoundation.CGFloat = 0.0, _ completion: ((Swift.Bool) -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) open func startAnimating(fininshIndex: Swift.Int = 0, _ completion: ((Swift.Bool) -> Swift.Void)?)
  @_Concurrency.MainActor(unsafe) open func startAnimating()
  @_Concurrency.MainActor(unsafe) open func stopAnimating()
  @_Concurrency.MainActor(unsafe) open func startAnimating(fininshIndex: Swift.Int = 0, offset: CoreFoundation.CGFloat, _ completion: ((Swift.Bool) -> Swift.Void)?)
  @objc deinit
}
final public class SizeValueProvider : GamificationFramework.AnyValueProvider {
  public typealias SizeValueBlock = (CoreFoundation.CGFloat) -> CoreFoundation.CGSize
  final public var size: CoreFoundation.CGSize {
    get
    set
  }
  public init(block: @escaping GamificationFramework.SizeValueProvider.SizeValueBlock)
  public init(_ size: CoreFoundation.CGSize)
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
extension GamificationFramework.AnimationView {
  @_Concurrency.MainActor(unsafe) convenience public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main, imageProvider: (any GamificationFramework.AnimationImageProvider)? = nil, animationCache: (any GamificationFramework.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  @_Concurrency.MainActor(unsafe) convenience public init(filePath: Swift.String, imageProvider: (any GamificationFramework.AnimationImageProvider)? = nil, animationCache: (any GamificationFramework.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  @_Concurrency.MainActor(unsafe) convenience public init(url: Foundation.URL, imageProvider: (any GamificationFramework.AnimationImageProvider)? = nil, closure: @escaping GamificationFramework.AnimationView.DownloadClosure, animationCache: (any GamificationFramework.AnimationCacheProvider)? = LRUAnimationCache.sharedCache)
  public typealias DownloadClosure = ((any Swift.Error)?) -> Swift.Void
}
extension UIKit.UIColor {
  public var lottieColorValue: GamificationFramework.Color {
    get
  }
}
public enum GameAction {
  case back
  public static func == (a: GamificationFramework.GameAction, b: GamificationFramework.GameAction) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Game {
  public enum GameNames : Swift.String, Swift.CaseIterable {
    case SpinNWin
    public init?(rawValue: Swift.String)
    public typealias AllCases = [GamificationFramework.Game.GameNames]
    public typealias RawValue = Swift.String
    public static var allCases: [GamificationFramework.Game.GameNames] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public static func dismissController()
  public static func openGame(controller: UIKit.UIViewController, complition: ((GamificationFramework.GameAction) -> Swift.Void)?)
  @objc deinit
}
extension GamificationFramework.IQKeyboardManager {
  @objc dynamic public var enableDebugging: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc dynamic public func registerAllNotifications()
  @objc dynamic public func unregisterAllNotifications()
}
final public class ColorValueProvider : GamificationFramework.AnyValueProvider {
  public typealias ColorValueBlock = (CoreFoundation.CGFloat) -> GamificationFramework.Color
  final public var color: GamificationFramework.Color {
    get
    set
  }
  public init(block: @escaping GamificationFramework.ColorValueProvider.ColorValueBlock)
  public init(_ color: GamificationFramework.Color)
  final public var valueType: any Any.Type {
    get
  }
  final public func hasUpdate(frame: CoreFoundation.CGFloat) -> Swift.Bool
  final public func value(frame: CoreFoundation.CGFloat) -> Any
  @objc deinit
}
public protocol AnimationFontProvider {
  func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
}
final public class DefaultFontProvider : GamificationFramework.AnimationFontProvider {
  final public func fontFor(family: Swift.String, size: CoreFoundation.CGFloat) -> CoreText.CTFont?
  public init()
  @objc deinit
}
public class FortuneWheelSlice : GamificationFramework.FortuneWheelSliceProtocol {
  public enum Style {
    case dark
    case light
    public static func == (a: GamificationFramework.FortuneWheelSlice.Style, b: GamificationFramework.FortuneWheelSlice.Style) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public var title: Swift.String
  public var degree: CoreFoundation.CGFloat
  public var backgroundColor: UIKit.UIColor? {
    get
  }
  public var fontColor: UIKit.UIColor {
    get
  }
  public var font: UIKit.UIFont {
    get
  }
  public var style: GamificationFramework.FortuneWheelSlice.Style
  public init(title: Swift.String)
  convenience public init(title: Swift.String, degree: CoreFoundation.CGFloat)
  public func drawAdditionalGraphics(in context: CoreGraphics.CGContext, circularSegmentHeight: CoreFoundation.CGFloat, radius: CoreFoundation.CGFloat, sliceDegree: CoreFoundation.CGFloat)
  @objc deinit
}
@objc extension UIKit.UIViewController {
  @objc @_Concurrency.MainActor(unsafe) dynamic public func parentIQContainerViewController() -> UIKit.UIViewController?
  @objc @available(*, deprecated, message: "Due to change in core-logic of handling distance between textField and keyboard distance, this layout contraint tweak is no longer needed and things will just work out of the box regardless of constraint pinned with safeArea/layoutGuide/superview.")
  @IBOutlet @_Concurrency.MainActor(unsafe) dynamic public var IQLayoutGuideConstraint: UIKit.NSLayoutConstraint? {
    @objc get
    @objc set(newValue)
  }
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) final public class AnimatedButton : GamificationFramework.AnimatedControl {
  @_Concurrency.MainActor(unsafe) final public func setPlayRange(fromProgress: GamificationFramework.AnimationProgressTime, toProgress: GamificationFramework.AnimationProgressTime, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor(unsafe) final public func setPlayRange(fromMarker fromName: Swift.String, toMarker toName: Swift.String, event: UIKit.UIControl.Event)
  @_Concurrency.MainActor(unsafe) override public init(animation: GamificationFramework.Animation)
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init()
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @_Concurrency.MainActor(unsafe) @objc override final public func beginTracking(_ touch: UIKit.UITouch, with event: UIKit.UIEvent?) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override final public func endTracking(_ touch: UIKit.UITouch?, with event: UIKit.UIEvent?)
  @objc deinit
}
@objc final public class CompatibleAnimation : ObjectiveC.NSObject {
  @objc public init(name: Swift.String, bundle: Foundation.Bundle = Bundle.main)
  @objc deinit
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc @_Concurrency.MainActor(unsafe) final public class CompatibleAnimationView : UIKit.UIView {
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(frame: CoreFoundation.CGRect)
  @objc @_Concurrency.MainActor(unsafe) final public var compatibleAnimation: GamificationFramework.CompatibleAnimation? {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var loopAnimationCount: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @_Concurrency.MainActor(unsafe) @objc override final public var contentMode: UIKit.UIView.ContentMode {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var shouldRasterizeWhenIdle: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentProgress: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentTime: Foundation.TimeInterval {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var currentFrame: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var realtimeAnimationFrame: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var realtimeAnimationProgress: CoreFoundation.CGFloat {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public var animationSpeed: CoreFoundation.CGFloat {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var respectAnimationFrameRate: Swift.Bool {
    @objc get
    @objc set
  }
  @objc @_Concurrency.MainActor(unsafe) final public var isAnimationPlaying: Swift.Bool {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) final public func play()
  @objc @_Concurrency.MainActor(unsafe) final public func play(completion: ((Swift.Bool) -> Swift.Void)?)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromProgress: CoreFoundation.CGFloat, toProgress: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromFrame: CoreFoundation.CGFloat, toFrame: CoreFoundation.CGFloat, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func play(fromMarker: Swift.String, toMarker: Swift.String, completion: ((Swift.Bool) -> Swift.Void)? = nil)
  @objc @_Concurrency.MainActor(unsafe) final public func stop()
  @objc @_Concurrency.MainActor(unsafe) final public func pause()
  @objc @_Concurrency.MainActor(unsafe) final public func reloadImages()
  @objc @_Concurrency.MainActor(unsafe) final public func forceDisplayUpdate()
  @objc @_Concurrency.MainActor(unsafe) final public func getValue(for keypath: GamificationFramework.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> Any?
  @objc @_Concurrency.MainActor(unsafe) final public func logHierarchyKeypaths()
  @objc @_Concurrency.MainActor(unsafe) final public func setColorValue(_ color: UIKit.UIColor, forKeypath keypath: GamificationFramework.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor(unsafe) final public func getColorValue(for keypath: GamificationFramework.CompatibleAnimationKeypath, atFrame: CoreFoundation.CGFloat) -> UIKit.UIColor?
  @objc @_Concurrency.MainActor(unsafe) final public func addSubview(_ subview: GamificationFramework.AnimationSubview, forLayerAt keypath: GamificationFramework.CompatibleAnimationKeypath)
  @objc @_Concurrency.MainActor(unsafe) final public func convert(rect: CoreFoundation.CGRect, toLayerAt keypath: GamificationFramework.CompatibleAnimationKeypath?) -> CoreFoundation.CGRect
  @objc @_Concurrency.MainActor(unsafe) final public func convert(point: CoreFoundation.CGPoint, toLayerAt keypath: GamificationFramework.CompatibleAnimationKeypath?) -> CoreFoundation.CGPoint
  @objc @_Concurrency.MainActor(unsafe) final public func progressTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc @_Concurrency.MainActor(unsafe) final public func frameTime(forMarker named: Swift.String) -> CoreFoundation.CGFloat
  @objc deinit
}
@_hasMissingDesignatedInitializers public class TTUtils {
  public class func uiColor(from rgbValue: Swift.UInt, alpha: CoreFoundation.CGFloat = 1.0) -> UIKit.UIColor
  @objc deinit
}
extension Foundation.Bundle {
  public static func sw_frameworkBundle() -> Foundation.Bundle
}
@objc @_inheritsConvenienceInitializers public class IQKeyboardReturnKeyHandler : ObjectiveC.NSObject {
  @objc weak public var delegate: (any UIKit.UITextFieldDelegate & UIKit.UITextViewDelegate)?
  @objc public var lastTextFieldReturnKeyType: UIKit.UIReturnKeyType {
    @objc get
    @objc set
  }
  @objc override dynamic public init()
  @objc public init(controller: UIKit.UIViewController)
  @objc deinit
  @objc public func addTextFieldView(_ view: UIKit.UIView)
  @objc public func removeTextFieldView(_ view: UIKit.UIView)
  @objc public func addResponderFromView(_ view: UIKit.UIView)
  @objc public func removeResponderFromView(_ view: UIKit.UIView)
}
extension GamificationFramework.IQKeyboardReturnKeyHandler : UIKit.UITextFieldDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldBeginEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldEndEditing(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldDidBeginEditing(_ textField: UIKit.UITextField)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldDidEndEditing(_ textField: UIKit.UITextField)
  @available(iOS 10.0, *)
  public typealias UITextFieldDidEndEditingReason = UIKit.UITextField.DidEndEditingReason
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldDidEndEditing(_ textField: UIKit.UITextField, reason: GamificationFramework.IQKeyboardReturnKeyHandler.UITextFieldDidEndEditingReason)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textField(_ textField: UIKit.UITextField, shouldChangeCharactersIn range: Foundation.NSRange, replacementString string: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldClear(_ textField: UIKit.UITextField) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textFieldShouldReturn(_ textField: UIKit.UITextField) -> Swift.Bool
}
extension GamificationFramework.IQKeyboardReturnKeyHandler : UIKit.UITextViewDelegate {
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewShouldBeginEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewShouldEndEditing(_ textView: UIKit.UITextView) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewDidBeginEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewDidEndEditing(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textView(_ textView: UIKit.UITextView, shouldChangeTextIn range: Foundation.NSRange, replacementText text: Swift.String) -> Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewDidChange(_ textView: UIKit.UITextView)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textViewDidChangeSelection(_ textView: UIKit.UITextView)
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS 10.0, *)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange, interaction: UIKit.UITextItemInteraction) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith URL: Foundation.URL, in characterRange: Foundation.NSRange) -> Swift.Bool
  @available(iOS, deprecated: 10.0)
  @_Concurrency.MainActor(unsafe) @objc dynamic public func textView(_ aTextView: UIKit.UITextView, shouldInteractWith textAttachment: UIKit.NSTextAttachment, in characterRange: Foundation.NSRange) -> Swift.Bool
}
extension GamificationFramework.Color : Swift.Codable {
  public init(from decoder: any Swift.Decoder) throws
  public func encode(to encoder: any Swift.Encoder) throws
}
public protocol AnimationTextProvider : AnyObject {
  func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
}
final public class DictionaryTextProvider : GamificationFramework.AnimationTextProvider {
  public init(_ values: [Swift.String : Swift.String])
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  @objc deinit
}
final public class DefaultTextProvider : GamificationFramework.AnimationTextProvider {
  final public func textFor(keypathName: Swift.String, sourceText: Swift.String) -> Swift.String
  public init()
  @objc deinit
}
public struct AnimationKeypath {
  public init(keypath: Swift.String)
  public init(keys: [Swift.String])
}
public class BundleImageProvider : GamificationFramework.AnimationImageProvider {
  public init(bundle: Foundation.Bundle, searchPath: Swift.String?)
  public func imageForAsset(asset: GamificationFramework.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
extension UIKit.UIImageView {
  @_Concurrency.MainActor(unsafe) public func loadGif(name: Swift.String)
  @available(iOS 9.0, *)
  @_Concurrency.MainActor(unsafe) public func loadGif(asset: Swift.String)
}
extension UIKit.UIImage {
  public class func gifModel(asset: Swift.String) -> UIKit.UIImage?
  public class func gif(data: Foundation.Data) -> UIKit.UIImage?
  public class func gif(url: Swift.String) -> UIKit.UIImage?
  public class func gif(name: Swift.String) -> UIKit.UIImage?
  @available(iOS 9.0, *)
  public class func gif(asset: Swift.String) -> UIKit.UIImage?
}
public class FilepathImageProvider : GamificationFramework.AnimationImageProvider {
  public init(filepath: Swift.String)
  public init(filepath: Foundation.URL)
  public func imageForAsset(asset: GamificationFramework.ImageAsset) -> CoreGraphics.CGImage?
  @objc deinit
}
extension UIKit.UINavigationController {
  @_Concurrency.MainActor(unsafe) @objc override dynamic open var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @objc get
  }
}
extension GamificationFramework.Animation {
  public static func named(_ name: Swift.String, bundle: Foundation.Bundle = Bundle.main, subdirectory: Swift.String? = nil, animationCache: (any GamificationFramework.AnimationCacheProvider)? = nil) -> GamificationFramework.Animation?
  public static func filepath(_ filepath: Swift.String, animationCache: (any GamificationFramework.AnimationCacheProvider)? = nil) -> GamificationFramework.Animation?
  public typealias DownloadClosure = (GamificationFramework.Animation?) -> Swift.Void
  public static func loadedFrom(url: Foundation.URL, closure: @escaping GamificationFramework.Animation.DownloadClosure, animationCache: (any GamificationFramework.AnimationCacheProvider)?)
  final public func progressTime(forMarker named: Swift.String) -> GamificationFramework.AnimationProgressTime?
  final public func frameTime(forMarker named: Swift.String) -> GamificationFramework.AnimationFrameTime?
  final public func progressTime(forFrame frameTime: GamificationFramework.AnimationFrameTime) -> GamificationFramework.AnimationProgressTime
  final public func frameTime(forProgress progressTime: GamificationFramework.AnimationProgressTime) -> GamificationFramework.AnimationFrameTime
  final public func time(forFrame frameTime: GamificationFramework.AnimationFrameTime) -> Foundation.TimeInterval
  final public func frameTime(forTime time: Foundation.TimeInterval) -> GamificationFramework.AnimationFrameTime
  final public var duration: Foundation.TimeInterval {
    get
  }
  final public var bounds: CoreFoundation.CGRect {
    get
  }
  final public var size: CoreFoundation.CGSize {
    get
  }
}
public let kIQUseDefaultKeyboardDistance: CoreFoundation.CGFloat
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var keyboardDistanceFromTextField: CoreFoundation.CGFloat {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var ignoreSwitchingByNextPrevious: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var enableMode: GamificationFramework.IQEnableMode {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldResignOnTouchOutsideMode: GamificationFramework.IQEnableMode {
    @objc get
    @objc set(newValue)
  }
}
@objc public class IQBarButtonItemConfiguration : ObjectiveC.NSObject {
  public typealias UIBarButtonSystemItem = UIKit.UIBarButtonItem.SystemItem
  @objc public init(barButtonSystemItem: GamificationFramework.IQBarButtonItemConfiguration.UIBarButtonSystemItem, action: ObjectiveC.Selector)
  @objc public init(image: UIKit.UIImage, action: ObjectiveC.Selector)
  @objc public init(title: Swift.String, action: ObjectiveC.Selector)
  final public let barButtonSystemItem: GamificationFramework.IQBarButtonItemConfiguration.UIBarButtonSystemItem?
  @objc final public let image: UIKit.UIImage?
  @objc final public let title: Swift.String?
  @objc final public let action: ObjectiveC.Selector?
  @objc deinit
}
@objc extension UIKit.UIImage {
  @objc public static func keyboardLeftImage() -> UIKit.UIImage?
  @objc public static func keyboardRightImage() -> UIKit.UIImage?
  @objc public static func keyboardUpImage() -> UIKit.UIImage?
  @objc public static func keyboardDownImage() -> UIKit.UIImage?
  @objc public static func keyboardPreviousImage() -> UIKit.UIImage?
  @objc public static func keyboardNextImage() -> UIKit.UIImage?
}
@objc extension UIKit.UIView {
  @objc @_Concurrency.MainActor(unsafe) dynamic public var keyboardToolbar: GamificationFramework.IQToolbar {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var shouldHideToolbarPlaceholder: Swift.Bool {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var toolbarPlaceholder: Swift.String? {
    @objc get
    @objc set(newValue)
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public var drawingToolbarPlaceholder: Swift.String? {
    @objc get
  }
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addKeyboardToolbarWithTarget(target: Swift.AnyObject?, titleText: Swift.String?, rightBarButtonConfiguration: GamificationFramework.IQBarButtonItemConfiguration?, previousBarButtonConfiguration: GamificationFramework.IQBarButtonItemConfiguration? = nil, nextBarButtonConfiguration: GamificationFramework.IQBarButtonItemConfiguration? = nil)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithImage(_ image: UIKit.UIImage, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightButtonOnKeyboardWithText(_ text: Swift.String, target: Swift.AnyObject?, action: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addCancelDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, cancelAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonTitle: Swift.String, rightButtonTitle: Swift.String, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addRightLeftOnKeyboardWithTarget(_ target: Swift.AnyObject?, leftButtonImage: UIKit.UIImage, rightButtonImage: UIKit.UIImage, leftButtonAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, shouldShowPlaceholder: Swift.Bool = false)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextDoneOnKeyboardWithTarget(_ target: Swift.AnyObject?, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, doneAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonImage: UIKit.UIImage, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
  @objc @_Concurrency.MainActor(unsafe) dynamic public func addPreviousNextRightOnKeyboardWithTarget(_ target: Swift.AnyObject?, rightButtonTitle: Swift.String, previousAction: ObjectiveC.Selector, nextAction: ObjectiveC.Selector, rightButtonAction: ObjectiveC.Selector, titleText: Swift.String?)
}
extension GamificationFramework.LayerType : Swift.Equatable {}
extension GamificationFramework.LayerType : Swift.Hashable {}
extension GamificationFramework.LayerType : Swift.RawRepresentable {}
extension GamificationFramework.MatteType : Swift.Equatable {}
extension GamificationFramework.MatteType : Swift.Hashable {}
extension GamificationFramework.MatteType : Swift.RawRepresentable {}
extension GamificationFramework.BlendMode : Swift.Equatable {}
extension GamificationFramework.BlendMode : Swift.Hashable {}
extension GamificationFramework.BlendMode : Swift.RawRepresentable {}
extension GamificationFramework.CoordinateSpace : Swift.Equatable {}
extension GamificationFramework.CoordinateSpace : Swift.Hashable {}
extension GamificationFramework.CoordinateSpace : Swift.RawRepresentable {}
extension GamificationFramework.IQAutoToolbarManageBehaviour : Swift.Equatable {}
extension GamificationFramework.IQAutoToolbarManageBehaviour : Swift.Hashable {}
extension GamificationFramework.IQAutoToolbarManageBehaviour : Swift.RawRepresentable {}
extension GamificationFramework.IQPreviousNextDisplayMode : Swift.Equatable {}
extension GamificationFramework.IQPreviousNextDisplayMode : Swift.Hashable {}
extension GamificationFramework.IQPreviousNextDisplayMode : Swift.RawRepresentable {}
extension GamificationFramework.IQEnableMode : Swift.Equatable {}
extension GamificationFramework.IQEnableMode : Swift.Hashable {}
extension GamificationFramework.IQEnableMode : Swift.RawRepresentable {}
extension GamificationFramework.GamesList : Swift.Equatable {}
extension GamificationFramework.GamesList : Swift.Hashable {}
extension GamificationFramework.AnimatedSwitch.CancelBehavior : Swift.Equatable {}
extension GamificationFramework.AnimatedSwitch.CancelBehavior : Swift.Hashable {}
extension GamificationFramework.LottieBackgroundBehavior : Swift.Equatable {}
extension GamificationFramework.LottieBackgroundBehavior : Swift.Hashable {}
extension GamificationFramework.CarnivalWheelSlice.Style : Swift.Equatable {}
extension GamificationFramework.CarnivalWheelSlice.Style : Swift.Hashable {}
extension GamificationFramework.ColorFormatDenominator : Swift.Equatable {}
extension GamificationFramework.ColorFormatDenominator : Swift.Hashable {}
extension GamificationFramework.GameAction : Swift.Equatable {}
extension GamificationFramework.GameAction : Swift.Hashable {}
extension GamificationFramework.Game.GameNames : Swift.Equatable {}
extension GamificationFramework.Game.GameNames : Swift.Hashable {}
extension GamificationFramework.Game.GameNames : Swift.RawRepresentable {}
extension GamificationFramework.FortuneWheelSlice.Style : Swift.Equatable {}
extension GamificationFramework.FortuneWheelSlice.Style : Swift.Hashable {}
